'''
Created on June 28, 2013

__author__ = "Elizabeth 'pidge' Flanagan"
__copyright__ = "Copyright 2012-2013, Intel Corp."
__credits__ = ["Elizabeth Flanagan"]
__license__ = "GPL"
__version__ = "2.0"
__maintainer__ = "Elizabeth Flanagan"
__email__ = "elizabeth.flanagan@intel.com"
'''
from buildbot.status.mail import MailNotifier
from buildbot.status.mail import *
from buildbot import interfaces, util, config
from buildbot.process.users import users
from buildbot.status import base
from buildbot.status.results import FAILURE, SUCCESS, WARNINGS, EXCEPTION, Results
from twisted.python import log

class YoctoMailNotifier(MailNotifier):
    def __init__(self, fromaddr, mode=("failing", "passing", "warnings"),
                 categories=None, branches=[], pokyrepos=[], builders=None, addLogs=False,
                 relayhost="localhost", buildSetSummary=False,
                 subject="buildbot %(result)s in %(title)s on %(builder)s",
                 lookup=None, extraRecipients=[],
                 sendToInterestedUsers=True, customMesg=None,
                 messageFormatter=defaultMessage, extraHeaders=None,
                 addPatch=True, useTls=False, 
                 smtpUser=None, smtpPassword=None, smtpPort=25):
        self.fromaddr = fromaddr
        self.mode=mode
        self.categories = categories
        self.branches = branches
        self.pokyrepos = pokyrepos
        self.builders = builders
        self.addLogs = addLogs
        self.relayhost = relayhost
        self.buildSetSummary = buildSetSummary
        self.subject = subject
        self.lookup = lookup
        self.extraRecipients = extraRecipients
        self.sendToInterestedUsers = sendToInterestedUsers
        self.customMesg = customMesg
        self.messageFormatter = messageFormatter
        self.extraHeaders = extraHeaders
        self.addPatch = addPatch
        self.useTls = useTls
        self.smtpUser = smtpUser
        self.smtpPassword = smtpPassword
        self.smtpPort = smtpPort
        MailNotifier.__init__(self, fromaddr, mode=self.mode,
                categories = self.categories, builders = self.builders,
                addLogs = self.addLogs, relayhost = self.relayhost,
                buildSetSummary = self.buildSetSummary,
                subject = self.subject,
                lookup = self.lookup,
                extraRecipients = self.extraRecipients,
                sendToInterestedUsers = self.sendToInterestedUsers,
                customMesg = self.customMesg, 
                messageFormatter = self.messageFormatter,
                extraHeaders = self.extraHeaders, addPatch = self.addPatch,
                useTls = self.useTls, smtpUser = self.smtpUser,
                smtpPassword = self.smtpPassword, smtpPort = self.smtpPort)

    def buildMessage(self, name, builds, results):
        patches = []
        logs = []
        msgdict = {"body":""}
        
        for build in builds:
            ss_list = build.getSourceStamps()
            if self.addPatch:
                for ss in ss_list:
                    if ss.patch:
                        patches.append(ss.patch)
            if self.addLogs:
                logs.extend(build.getLogs())
            
            tmp = self.buildMessageDict(name=build.getBuilder().name,
                                        build=build, results=build.results)
            msgdict['body'] += tmp['body']
            msgdict['body'] += '\n\n'
            msgdict['type'] = tmp['type']
            if "subject" in tmp:
                msgdict['subject'] = tmp['subject']
            if ss.repository or ss.repository in self.pokyrepos: 
                if ss.branch or ss.branch in self.branches:
                    d = self.createEmail(msgdict, name, self.master_status.getTitle(),
                                        results, builds, patches, logs)
                    @d.addCallback
                    def getRecipients(m):
                        # now, who is this message going to?
                        if self.sendToInterestedUsers:
                            dl = []
                            for build in builds:
                                if self.lookup:
                                    d = self.useLookup(build)
                                else:
                                    d = self.useUsers(build)
                                dl.append(d)
                            d = defer.gatherResults(dl)
                        else:
                            d = defer.succeed([])
                        d.addCallback(self._gotRecipients, m)
                    return d

