# This file is part of Buildbot.  Buildbot is free software: you can
# redistribute it and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation, version 2.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Copyright Buildbot Team Members
#
#
'''
Created on Jan 14, 2012

__copyright__ = "Copyright Buildbot Team Members"
__credits__ = ["Elizabeth Flanagan"]
__license__ = "GPL"
__version__ = "2.0"
__maintainer__ = "Elizabeth Flanagan"
__email__ = "elizabeth.flanagan@intel.com"
'''
from twisted.python import log
from twisted.internet import defer

import os
from buildbot.steps.source.git import Git
from buildbot import config
from buildbot.status import build
from buildbot.process import buildstep

class CheckOutLayers(Git):
    haltOnFailure = False
    flunkOnFailure = True
    def __init__(self, factory, scheduler=None, layername=None, mode='full', 
                method='clobber', submodules=False, shallow=False, 
                timeout=100000, progress=True, retryFetch=False, clobberOnFailure=False, 
                getDescription=True, argdict=None,
                 **kwargs):
        for k, v in argdict.iteritems():
             setattr(self, k, v)
        self.description = "Checking out " + layername
        self.scheduler = scheduler
        self.branch = ""
        self.commit = ""
        self.method = method
        self.prog = progress
        self.repourl = ""
        self.retryFetch = retryFetch
        self.submodules = submodules
        self.shallow = shallow
        self.fetchcount = 0
        self.clobberOnFailure = clobberOnFailure
        self.mode = mode
        self.timeout = 100000
        self.getDescription = getDescription
        self.layername = layername
        self.name="Git checkout of " + layername
        kwargs['timeout']=self.timeout
        for k, v in argdict.iteritems():
            setattr(self, k, v)
        Git.__init__(self, repourl=self.repourl, branch=self.branch, mode=self.mode,
                 method=self.method, submodules=self.submodules, 
                 shallow=self.shallow, progress=self.progress, 
                 retryFetch=self.retryFetch, 
                 clobberOnFailure=self.clobberOnFailure, 
                 getDescription=self.getDescription,
                 **kwargs)

    def startVC(self, branch, revision, patch):
        if self.getProperty('branch_trigger_'+self.layername+"_"+self.scheduler):
            self.branch = self.getProperty('branch_trigger_'+self.layername+"_"+self.scheduler)
        elif self.getProperty('branch_triggerer_'+self.layername+"_"+self.scheduler) :
            self.branch = self.getProperty('branch_triggerer_'+self.layername+"_"+self.scheduler)
        elif self.getProperty('branch_'+self.layername):
            self.branch = self.getProperty('branch_'+self.layername)
        else:
            self.branch = "master"
        if self.getProperty('repo_trigger_'+self.layername+"_"+self.scheduler):
            self.repourl = self.getProperty('repo_trigger_'+self.layername+"_"+self.scheduler)
        elif self.getProperty('repo_triggerer_'+self.layername+"_"+self.scheduler) :
            self.repourl = self.getProperty('repo_triggerer_'+self.layername+"_"+self.scheduler)
        elif self.getProperty('repo_'+self.layername):
            self.repourl = self.getProperty('repo_'+self.layername)
        else:self.repourl = "git://git.yoctoproject.com/poky"

        if self.getProperty('commit_trigger_'+self.layername+"_"+self.scheduler):
            self.commit = self.getProperty('commit_trigger_'+self.layername+"_"+self.scheduler)
        elif self.getProperty('commit_triggerer_'+self.layername+"_"+self.scheduler) :
            self.commit = self.getProperty('commit_triggerer_'+self.layername+"_"+self.scheduler)
        elif self.getProperty('commit_'+self.layername):
            self.commit = self.getProperty('commit_'+self.layername)
        else:
            self.commit = "HEAD"

        self.setProperty('repourl_' + self.layername, self.repourl, "CheckOutLayers")
        self.setProperty('branch_' + self.layername, self.branch, "CheckOutLayers")
        self.setProperty('commit_' + self.layername, self.commit, "CheckOutLayers")
        Git.startVC(self, branch=self.branch, patch=None, revision=self.commit)


    def clobber(self):
        cmd = buildstep.RemoteCommand('rmdir', {'dir': self.workdir,
                                                'logEnviron': self.logEnviron,
                                                'timeout': 100000})
        cmd.useLog(self.stdio_log, False)
        d = self.runCommand(cmd)
        def checkRemoval(res):
            if res != 0:
                raise RuntimeError("Failed to delete directory")
            return res
        d.addCallback(lambda _: checkRemoval(cmd.rc))
        d.addCallback(lambda _: self._doFull())
        return d

    @defer.inlineCallbacks
    def parseGotRevision(self, _=None):
        stdout = yield self._dovccmd(['rev-parse', 'HEAD'], collectStdout=True)
        revision = stdout.strip()
        if len(revision) != 40:
            raise buildstep.BuildStepFailed()
        if self.layername == "poky":
            self.updateSourceProperty('got_revision', revision)
        self.updateSourceProperty('got_revision_' + self.layername, revision)
        defer.returnValue(0)
